#include <iostream>
#include <vector>
#include <cmath>
#include <tuple>
#include <limits>
#include <stack>
#include <algorithm>

struct Point {
	double a;
	double b;
	int   id;
};

struct Edge {
	Point a;
	Point b;
	int distance;

	void print() {
		std::cout << "(" << a.a << ", " << a.b << ") to (" << b.a << ", " << 
		b.b << ") Distance: " << distance << std::endl; 
	}

	void print_ids() {
		std::cout << a.id << "to " << b.id << ", " << " Distance: " << distance << std::endl; 
	}
};

// Edge distance compare operator
bool operator< (const Edge& a, const Edge& b) {
	return a.distance < b.distance;
}

struct SimpleEdge {
	int src;
	int dst;
	int distance;

	void print() {
		std::cout << src << " " << dst << std::endl;
	}
};

// Structure for union by rank (rank associated with depth of tree which allows us to keep the resulting tree small)
struct Subset {
	int parent;
	int rank;
};


// Function declarations
int distance(Point, Point);
int MST_Kruskals();
void DFS(int, std::vector<std::vector<int>>);
void link(int, int, std::vector<Subset> &);
int find(std::vector<Subset> &, int);
void Union(std::vector<Subset>&, int, int);


// Global variables
std::vector <Point> points;
std::vector <Edge> edges;

std::vector<bool> visited;
std::vector<std::vector<int>> adjMatrix;

using namespace std;
int main() {
	int nrOfPoints = 0;


	cin >> nrOfPoints;

	double a;
	double b;
	for(int i = 0; i < nrOfPoints; ++i) {
		cin >> a;
		cin >> b;
		Point point;
		point.a = a;
		point.b = b;
		point.id = i;
		points.push_back(point);
	}
/*
	distMat.resize(points.size(), vector<int>(points.size()));

	for (int i = 0; i < distMat.size(); ++i) {
		for(int j = 0; j < distMat[i].size(); ++j) {
			distMat[i][j] = 0;
		}
	}
*/
	for(int i = 0; i < nrOfPoints; ++i) {
		for(int j = 1; j < nrOfPoints-i; ++j) {
			int dist = distance(points[i], points[j]);
			Edge edge;
			edge.a = points[i];
			edge.b = points[j];
			edge.distance = dist;
			edges.push_back(edge);
		}
	}
/*
	for(int i = 0; i < edges.size(); ++i) {
		edges[i].print_ids();
	}
*/

	
	int root = MST_Kruskals();




	visited.resize(points.size());

	for(int i = 0; i < visited.size(); ++i) {
		visited[i] = false;
	}

	//cout << "Root: " << root << endl;
	DFS(root, adjMatrix);
	

/*
	for(int i = 0; i < tree.size(); ++i) {
		tree[i].print();
	}
*/
	

	return 0;
};


int MST_Kruskals() {
	// Sort edges
	sort(edges.begin(), edges.end());

	// Initialize tree vector
	vector<SimpleEdge> tree;
	adjMatrix.resize(points.size(), vector<int>(points.size()));
	//vector<vector<int>> adjMatrix(points.size(), vector<int>(points.size()));
	//vector<vector<int>> adjList(points.size());

	for(int i = 0; i < adjMatrix.size(); ++i) {
		for(int j = 0; j < adjMatrix[i].size(); ++j) {
			adjMatrix[i][j] = 0;
		}
	}

	// Make-set, create a new set containing the single element x
	vector<Subset> subsets(points.size());

	// Initialize values for union by rank
	for(int i = 0; i < subsets.size(); ++i) {
		subsets[i].parent = i;
		subsets[i].rank = 0;
	}

	for(int i = 0; i < edges.size(); ++i) {

		int x = find(subsets, edges[i].a.id);
    	int y = find(subsets, edges[i].b.id);

    	// Check for cycles
    	if(y != x) {
    		SimpleEdge simpleEdge;
	    	simpleEdge.src = edges[i].a.id;
	    	simpleEdge.dst = edges[i].b.id;
	    	//simpleEdge.distance = edges[i].distance;

	    	//adjList[simpleEdge.src].push_back(simpleEdge.dst);
	    	//adjList[simpleEdge.dst].push_back(simpleEdge.src);
	    	adjMatrix[simpleEdge.src][simpleEdge.dst] = 1;
	    	adjMatrix[simpleEdge.dst][simpleEdge.src] = 1;

	    	tree.push_back(simpleEdge);
	    	Union(subsets, x, y);
    	}

	}

	return find(subsets, 0);

}

/**
 * @brief      Change parent of smaller root to the higher root
 *
 * @param[in]  x        { root x }
 * @param[in]  y        { root y }
 * @param[in]  subsets  The subsets
 */
void link(int x, int y, vector<Subset> &subsets) {

	// Link the smaller rank tree to the higher rank tree for union by rank
	if (subsets[x].rank < subsets[y].rank) {
        subsets[x].parent = y;
    } else if (subsets[x].rank > subsets[y].rank) {
    	subsets[y].parent = x;
    } else {
    	subsets[x].parent = y;
    	subsets[y].rank++;
    }
}

/**
 * @brief      Searches for the first match.
 *
 * @param      subsets  The subsets
 *
 * @return     { description_of_the_return_value }
 */
int find(vector<Subset> &subsets, int x) {
	if(subsets[x].parent != x) {
		subsets[x].parent = find(subsets, subsets[x].parent);
	}

	return subsets[x].parent;
}

void Union(vector<Subset> &subsets, int x, int y) {
	link(find(subsets, x), find(subsets, y), subsets);
}

void DFS(int v, vector<vector<int>> adjMatrix) {
	cout << v << endl;
	visited[v] = true;

	for(int i = 0; i < points.size(); ++i) {
		if(!visited[i] && adjMatrix[v][i]) {
			DFS(i, adjMatrix);
		}
	}

}